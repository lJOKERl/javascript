var arr = [
"Например, бесконечность Infinity получается при делении на ноль.",
"Значение null не относится ни к одному из типов выше, а образует свой отдельный тип, состоящий из единственного значения null.",
"Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.",
"В явном виде undefined обычно не присваивают, так как это противоречит его смыслу. Для записи в переменную «пустого» или «неизвестного» значения используется null.",
"Есть 5 «примитивных» типов: number, string, boolean, null, undefined и 6-й тип – объекты object.",
"Инкремент/декремент можно применить только к переменной. Код 5++ даст ошибку.",
"Постфиксная форма i++ отличается от префиксной ++i тем, что возвращает старое значение, бывшее до увеличения.",
"Значение NaN по стандарту устроено так, что сравнения ==, <, >, <=, >= и даже === с ним возвращают false.",
"Вызов prompt возвращает то, что ввёл посетитель – строку или специальное значение null, если ввод отменён.",
"confirm выводит окно с вопросом. Результатом будет true при нажатии OK и false – при CANCEL(Esc).",
"Число 0, пустая строка '', null и undefined, а также NaN являются false. Остальные значения – true.",
"access = (age > 14) ? true : false;",
"|| запинается на «правде», && запинается на «лжи».",
"Если все значения «ложные», то || возвратит последнее из них",
"Итак, оператор && вычисляет операнды слева направо до первого «ложного» и возвращает его, а если все истинные – то последнее значение.",
"Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.",
"Для преобразования к числу в явном виде можно вызвать Number(val), либо, что короче, поставить перед выражением унарный плюс \"+\"",
"Все значения, которые интуитивно «пусты», становятся false. Их несколько: 0, пустая строка, null, undefined и NaN.",
"Числа	Все true, кроме 0, NaN -- false.",
"Строки	Все true, кроме пустой строки \"\" -- false",
"Объекты Всегда true",
"Директива continue прекращает выполнение текущей итерации цикла.",
"Синтаксические конструкции, которые не возвращают значений, нельзя использовать в операторе '?'.",
"Директива return может также использоваться без значения, чтобы прекратить выполнение и выйти из функции.",
"В случае, когда функция не вернула значение или return был без аргументов, считается что она вернула undefined",
"Function Declaration – функция, объявленная в основном потоке кода.",
"Function Expression – объявление функции в контексте какого-либо выражения, например присваивания.",
"Функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.",
"Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.",
"Функции в JavaScript являются значениями. Их можно присваивать, передавать, создавать в любом месте кода.",
"Если нет явной причины использовать Function Expression – предпочитайте Function Declaration.",
"При любом вложенном вызове JavaScript запоминает текущий контекст выполнения в специальной внутренней структуре данных – «стеке контекстов».",
"Тесты BDD – это три в одном: И тесты, И документация, И примеры использования.",
"Mocha – эта библиотека содержит общие функции для тестирования, включая describe и it.",
"Chai – библиотека поддерживает разнообразные функции для проверок. Есть разные «стили» проверки результатов, с которыми мы познакомимся позже, на текущий момент мы будем использовать лишь assert.equal.",
"Есть методы и у чисел, например num.toFixed(n). Он округляет число num до n знаков после запятой, при необходимости добивает нулями до данной длины и возвращает в виде строки",
"При делении на очень-очень маленькое число должно получиться очень большое. В математическом анализе это описывается через пределы, и если подразумевать предел, то в качестве результата деления на 0 мы получаем «бесконечность», которая обозначается символом ∞ (в JavaScript Infinity).",
"Infinity – особенное численное значение, которое ведет себя в точности как математическая бесконечность ∞.",
"Infinity больше любого числа.",
"Добавление к бесконечности не меняет её.",
"Если математическая операция не может быть совершена, то возвращается специальное значение NaN (Not-A-Number).",
"Деление 0/0 в математическом смысле неопределено, поэтому его результат NaN:",
"Значение NaN – единственное в своем роде, которое не равно ничему, включая себя.",
"Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает true, если получилось NaN, и false – для любого другого значения.",
"Значение NaN «прилипчиво». Любая операция с NaN возвращает NaN.",
"Если аргумент isNaN – не число, то он автоматически преобразуется к числу.",
"Итак, в JavaScript есть обычные числа и три специальных числовых значения: NaN, Infinity и -Infinity.",
"Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity",
"Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.",
"Вариант округления через Math.round получился более корректным, так как по общепринятым правилам 5 округляется вверх. А toFixed может округлить его как вверх, так и вниз.",
"Числа могут быть записаны в десятеричной, шестнадцатиричной системах, а также «научным» способом.",
"Чтобы получить символ, используйте вызов charAt(позиция). Первый символ имеет позицию 0",
"Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний",
"Для поиска подстроки есть метод indexOf(подстрока[, начальная_позиция]).",
"Для красивого вызова indexOf применяется побитовый оператор НЕ '~'.",
"Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Как только получаем очередную позицию – начинаем следующий поиск со следующей.",
"Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end. Если аргумент end отсутствует, то идет до конца строки",
"В substr(start [, length]) первый аргумент имеет такой же смысл, как и в substring, а второй содержит не конечную позицию, а количество символов. Если второго аргумента нет – подразумевается «до конца строки».",
"slice(start [, end]) Возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров – такой же как в substring.",
"String.fromCharCode(code) Возвращает символ по коду code",
"str.charCodeAt(pos) Возвращает код символа на позиции pos. Отсчет позиции начинается с нуля.",
"В JavaScript можно обратиться к любому свойству объекта, даже если его нет. Вернется специальное значение undefined",
"Существует альтернативный синтаксис работы со свойствами, использующий квадратные скобки объект['свойство']. Квадратные скобки также позволяют обратиться к свойству, имя которого хранится в переменной.",
"Записи person['name'] и person.name идентичны, но квадратные скобки позволяют использовать в качестве имени свойства любую строку",
"При создании множества объектов одного и того же вида (с одинаковыми полями) интерпретатор выносит описание полей в отдельную структуру. А сам объект остаётся в виде непрерывной области памяти с данными.",
"Для перебора всех свойств из объекта используется цикл по свойствам for..in.",
"Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые – сортируются (в современных браузерах).",
"В переменной, которой присвоен объект, хранится не сам объект, а «адрес его места в памяти», иными словами – «ссылка» на него.",
"При копировании переменной с объектом – копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре. Так как объект всего один, то изменения через любую переменную видны в других переменных.",
"При «раскрытии» свойств объекта в консоли – браузер всегда выводит их текущие (на момент раскрытия) значения.",
"В массиве может храниться любое число элементов любого типа.",
"Массив – это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length.",
"Длина length – не количество элементов массива, а последний индекс + 1.",
"При уменьшении length массив укорачивается.",
"Не ставить массиву произвольные свойства, такие как arr.test = 5. То есть, работать именно как с массивом, а не как с объектом.",
"Метод split(s), который позволяет превратить строку в массив, разбив ее по разделителю",
"У метода split есть необязательный второй аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано – остаток массива будет отброшен",
"Вызов arr.join(str) делает в точности противоположное split. Он берет массив и склеивает его в строку, используя str как разделитель.",
"Метод splice – это универсальный раскладной нож для работы с массивами. Умеет все: удалять элементы, вставлять элементы, заменять элементы – по очереди и одновременно.",
"Метод slice(begin, end) копирует участок массива от begin до end, не включая end. Исходный массив при этом не меняется.",
"Метод sort() сортирует массив.",
"Метод arr.reverse() меняет порядок элементов в массиве на обратный.",
"Метод arr.concat(value1, value2, … valueN) создаёт новый массив, в который копируются элементы",
"У concat есть одна забавная особенность. Если аргумент concat – массив, то concat добавляет элементы из него.",
"Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или -1, если его нет.",
"Метод «arr.forEach(callback[, thisArg])» используется для перебора массива. Он для каждого элемента массива вызывает функцию callback. Этой функции он передаёт три параметра callback(item, i, arr)",
"Метод «arr.filter(callback[, thisArg])» используется для фильтрации массива через функцию. Он создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true.",
"Метод «arr.map(callback[, thisArg])» используется для трансформации массива. Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr.",
"Метод «arr.every(callback[, thisArg])» возвращает true, если вызов callback вернёт true для каждого элемента arr.",
"Метод «arr.some(callback[, thisArg])» возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr.",
"Метод «arr.reduce(callback[, initialValue])» используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.",
"Если вы не используете строгий режим, то чтобы переменные не менялись «неожиданно», рекомендуется никогда не изменять arguments.",
"arguments – это не массив. Частая ошибка новичков – попытка применить методы Array к arguments. Это невозможно!",
"В современных браузерах (кроме IE9-) вызов performance.now() возвращает количество миллисекунд, прошедшее с начала загрузки страницы. Причём именно с самого начала, до того, как загрузился HTML-файл, если точнее – с момента выгрузки предыдущей страницы из памяти.",
"Для измерения с одновременным выводом результатов в консоли есть методы: console.time(метка) – включить внутренний хронометр браузера с меткой. console.timeEnd(метка) – выключить внутренний хронометр браузера с меткой и вывести результат.",
"toString(), toDateString(), toTimeString() Возвращают стандартное строчное представление, не заданное жёстко в стандарте, а зависящее от браузера. Единственное требование к нему – читаемость человеком. Метод toString возвращает дату целиком, toDateString() и toTimeString() – только дату и время соответственно.",
"Для получения текущей даты в миллисекундах лучше использовать Date.now(), чтобы не создавать лишний объект Date",
"Для бенчмаркинга лучше использовать performance.now() (кроме IE9-), он в 1000 раз точнее.",
"Глобальными называют переменные и функции, которые не находятся внутри какой-то функции. То есть, иными словами, если переменная или функция не находятся внутри конструкции function, то они – «глобальные».",
"В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется «глобальный объект» (global object).",
"Присваивая или читая глобальную переменную, мы, фактически, работаем со свойствами window.",
"Во время инициализации скрипт сканируется на предмет объявления функций вида Function Declaration, а затем – на предмет объявления переменных var. Каждое такое объявление добавляется в window.",
"Функции, объявленные как Function Declaration, создаются сразу работающими, а переменные – равными undefined.",
"Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске.",
"Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем LexicalEnvironment, а затем, если её нет – ищет во внешнем объекте переменных. ",
"При создании функция получает скрытое свойство [[Scope]], которое ссылается на лексическое окружение, в котором она была создана.",
"Переменную во внешней области видимости можно не только читать, но и изменять.",
"Функция в JavaScript является объектом, поэтому можно присваивать свойства прямо к ней - f.test = 5; Свойства функции не стоит путать с переменными и параметрами. Они совершенно никак не связаны. Переменные доступны только внутри функции, они создаются в процессе её выполнения. Это – использование функции «как функции». А свойство у функции – доступно отовсюду и всегда. Это – использование функции «как объекта».",
"Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.",
"При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».",
"При создании функции с использованием new Function, её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window.",
"Есть одно упрощение для работы с памятью: «значение остаётся в памяти, пока на него есть хотя бы одна ссылка».",
"Свойства-функции называют «методами» объектов. Их можно добавлять и удалять в любой момент, в том числе и явным присваиванием",
"Если одну и ту же функцию запускать в контексте разных объектов, она будет получать разный this",
"Любой объект в логическом контексте – true, даже если это пустой массив [] или объект {}.",
"Если в объекте присутствует метод toString, который возвращает примитив, то он используется для преобразования.",
"Все объекты, включая встроенные, имеют свои реализации метода toString",
"У объектов Date есть и valueOf – возвращает количество миллисекунд, и toString – возвращает строку с датой.",
"При строковом преобразовании объекта используется его метод toString. Он должен возвращать примитивное значение, причём не обязательно именно строку.",
"вызов return с объектом вернёт объект, а с чем угодно, кроме объекта – возвратит, как обычно, this.",
];

// Генерация случаюного числа от одного до максимального числа массива
function getRandomInRange() {
	var min = 1;
	var max = arr.length - 1;

 	return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Получение случайной строки
function GetString() {
	var num = getRandomInRange(),
		content = arr[num];

		return content;
}

function WriteText() {
	var text = document.querySelector("#text");
	text.textContent = GetString();

	text.style.textAlign = 'left';
	text.style.fontSize = '1em';
	

	if (text.textContent.length < 90) {
		text.style.textAlign = 'center';
		text.style.fontSize = '1.2em';
	}

}

setInterval(WriteText, 3000);

