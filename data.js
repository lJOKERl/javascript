var arr = [
"Например, бесконечность Infinity получается при делении на ноль.",
"Значение null не относится ни к одному из типов выше, а образует свой отдельный тип, состоящий из единственного значения null.",
"Если переменная объявлена, но в неё ничего не записано, то её значение как раз и есть undefined.",
"В явном виде undefined обычно не присваивают, так как это противоречит его смыслу. Для записи в переменную «пустого» или «неизвестного» значения используется null.",
"Есть 5 «примитивных» типов: number, string, boolean, null, undefined и 6-й тип – объекты object.",
"Инкремент/декремент можно применить только к переменной. Код 5++ даст ошибку.",
"Постфиксная форма i++ отличается от префиксной ++i тем, что возвращает старое значение, бывшее до увеличения.",
"Значение NaN по стандарту устроено так, что сравнения ==, <, >, <=, >= и даже === с ним возвращают false.",
"Вызов prompt возвращает то, что ввёл посетитель – строку или специальное значение null, если ввод отменён.",
"confirm выводит окно с вопросом. Результатом будет true при нажатии OK и false – при CANCEL(Esc).",
"Число 0, пустая строка '', null и undefined, а также NaN являются false. Остальные значения – true.",
"access = (age > 14) ? true : false;",
"|| запинается на «правде», && запинается на «лжи».",
"Если все значения «ложные», то || возвратит последнее из них",
"Итак, оператор && вычисляет операнды слева направо до первого «ложного» и возвращает его, а если все истинные – то последнее значение.",
"Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.",
"Для преобразования к числу в явном виде можно вызвать Number(val), либо, что короче, поставить перед выражением унарный плюс \"+\"",
"Все значения, которые интуитивно «пусты», становятся false. Их несколько: 0, пустая строка, null, undefined и NaN.",
"Числа	Все true, кроме 0, NaN -- false.",
"Строки	Все true, кроме пустой строки \"\" -- false",
"Объекты Всегда true",
"Директива continue прекращает выполнение текущей итерации цикла.",
"Синтаксические конструкции, которые не возвращают значений, нельзя использовать в операторе '?'.",
"Директива return может также использоваться без значения, чтобы прекратить выполнение и выйти из функции.",
"В случае, когда функция не вернула значение или return был без аргументов, считается что она вернула undefined",
"Function Declaration – функция, объявленная в основном потоке кода.",
"Function Expression – объявление функции в контексте какого-либо выражения, например присваивания.",
"Функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.",
"Функциональное выражение, которое не записывается в переменную, называют анонимной функцией.",
"Функции в JavaScript являются значениями. Их можно присваивать, передавать, создавать в любом месте кода.",
"Если нет явной причины использовать Function Expression – предпочитайте Function Declaration.",
"При любом вложенном вызове JavaScript запоминает текущий контекст выполнения в специальной внутренней структуре данных – «стеке контекстов».",
"Тесты BDD – это три в одном: И тесты, И документация, И примеры использования.",
"Mocha – эта библиотека содержит общие функции для тестирования, включая describe и it.",
"Chai – библиотека поддерживает разнообразные функции для проверок. Есть разные «стили» проверки результатов, с которыми мы познакомимся позже, на текущий момент мы будем использовать лишь assert.equal.",
"Есть методы и у чисел, например num.toFixed(n). Он округляет число num до n знаков после запятой, при необходимости добивает нулями до данной длины и возвращает в виде строки",
"При делении на очень-очень маленькое число должно получиться очень большое. В математическом анализе это описывается через пределы, и если подразумевать предел, то в качестве результата деления на 0 мы получаем «бесконечность», которая обозначается символом ∞ (в JavaScript Infinity).",
"Infinity – особенное численное значение, которое ведет себя в точности как математическая бесконечность ∞.",
"Infinity больше любого числа.",
"Добавление к бесконечности не меняет её.",
"Если математическая операция не может быть совершена, то возвращается специальное значение NaN (Not-A-Number).",
"Деление 0/0 в математическом смысле неопределено, поэтому его результат NaN:",
"Значение NaN – единственное в своем роде, которое не равно ничему, включая себя.",
"Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает true, если получилось NaN, и false – для любого другого значения.",
"Значение NaN «прилипчиво». Любая операция с NaN возвращает NaN.",
"Если аргумент isNaN – не число, то он автоматически преобразуется к числу.",
"Итак, в JavaScript есть обычные числа и три специальных числовых значения: NaN, Infinity и -Infinity.",
"Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity",
"Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно.",
"Вариант округления через Math.round получился более корректным, так как по общепринятым правилам 5 округляется вверх. А toFixed может округлить его как вверх, так и вниз.",
"Числа могут быть записаны в десятеричной, шестнадцатиричной системах, а также «научным» способом.",
"Чтобы получить символ, используйте вызов charAt(позиция). Первый символ имеет позицию 0",
"Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний",
"Для поиска подстроки есть метод indexOf(подстрока[, начальная_позиция]).",
"Для красивого вызова indexOf применяется побитовый оператор НЕ '~'.",
"Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле. Как только получаем очередную позицию – начинаем следующий поиск со следующей.",
"Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end. Если аргумент end отсутствует, то идет до конца строки",
"В substr(start [, length]) первый аргумент имеет такой же смысл, как и в substring, а второй содержит не конечную позицию, а количество символов. Если второго аргумента нет – подразумевается «до конца строки».",
"slice(start [, end]) Возвращает часть строки от позиции start до, но не включая, позиции end. Смысл параметров – такой же как в substring.",
"String.fromCharCode(code) Возвращает символ по коду code",
"str.charCodeAt(pos) Возвращает код символа на позиции pos. Отсчет позиции начинается с нуля.",
"В JavaScript можно обратиться к любому свойству объекта, даже если его нет. Вернется специальное значение undefined",
"Существует альтернативный синтаксис работы со свойствами, использующий квадратные скобки объект['свойство']. Квадратные скобки также позволяют обратиться к свойству, имя которого хранится в переменной.",
"Записи person['name'] и person.name идентичны, но квадратные скобки позволяют использовать в качестве имени свойства любую строку",
"При создании множества объектов одного и того же вида (с одинаковыми полями) интерпретатор выносит описание полей в отдельную структуру. А сам объект остаётся в виде непрерывной области памяти с данными.",
"Для перебора всех свойств из объекта используется цикл по свойствам for..in.",
"Порядок перебора соответствует порядку объявления для нечисловых ключей, а числовые – сортируются (в современных браузерах).",
"В переменной, которой присвоен объект, хранится не сам объект, а «адрес его места в памяти», иными словами – «ссылка» на него.",
"При копировании переменной с объектом – копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре. Так как объект всего один, то изменения через любую переменную видны в других переменных.",
"При «раскрытии» свойств объекта в консоли – браузер всегда выводит их текущие (на момент раскрытия) значения.",
"В массиве может храниться любое число элементов любого типа.",
"Массив – это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length.",
"Длина length – не количество элементов массива, а последний индекс + 1.",
"При уменьшении length массив укорачивается.",
"Не ставить массиву произвольные свойства, такие как arr.test = 5. То есть, работать именно как с массивом, а не как с объектом.",
"Метод split(s), который позволяет превратить строку в массив, разбив ее по разделителю",
"У метода split есть необязательный второй аргумент – ограничение на количество элементов в массиве. Если их больше, чем указано – остаток массива будет отброшен",
"Вызов arr.join(str) делает в точности противоположное split. Он берет массив и склеивает его в строку, используя str как разделитель.",
"Метод splice – это универсальный раскладной нож для работы с массивами. Умеет все: удалять элементы, вставлять элементы, заменять элементы – по очереди и одновременно.",
"Метод slice(begin, end) копирует участок массива от begin до end, не включая end. Исходный массив при этом не меняется.",
"Метод sort() сортирует массив.",
"Метод arr.reverse() меняет порядок элементов в массиве на обратный.",
"Метод arr.concat(value1, value2, … valueN) создаёт новый массив, в который копируются элементы",
"У concat есть одна забавная особенность. Если аргумент concat – массив, то concat добавляет элементы из него.",
"Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или -1, если его нет.",
"Метод «arr.forEach(callback[, thisArg])» используется для перебора массива. Он для каждого элемента массива вызывает функцию callback. Этой функции он передаёт три параметра callback(item, i, arr)",
"Метод «arr.filter(callback[, thisArg])» используется для фильтрации массива через функцию. Он создаёт новый массив, в который войдут только те элементы arr, для которых вызов callback(item, i, arr) возвратит true.",
"Метод «arr.map(callback[, thisArg])» используется для трансформации массива. Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr.",
"Метод «arr.every(callback[, thisArg])» возвращает true, если вызов callback вернёт true для каждого элемента arr.",
"Метод «arr.some(callback[, thisArg])» возвращает true, если вызов callback вернёт true для какого-нибудь элемента arr.",
"Метод «arr.reduce(callback[, initialValue])» используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.",
"Если вы не используете строгий режим, то чтобы переменные не менялись «неожиданно», рекомендуется никогда не изменять arguments.",
"arguments – это не массив. Частая ошибка новичков – попытка применить методы Array к arguments. Это невозможно!",
"В современных браузерах (кроме IE9-) вызов performance.now() возвращает количество миллисекунд, прошедшее с начала загрузки страницы. Причём именно с самого начала, до того, как загрузился HTML-файл, если точнее – с момента выгрузки предыдущей страницы из памяти.",
"Для измерения с одновременным выводом результатов в консоли есть методы: console.time(метка) – включить внутренний хронометр браузера с меткой. console.timeEnd(метка) – выключить внутренний хронометр браузера с меткой и вывести результат.",
"toString(), toDateString(), toTimeString() Возвращают стандартное строчное представление, не заданное жёстко в стандарте, а зависящее от браузера. Единственное требование к нему – читаемость человеком. Метод toString возвращает дату целиком, toDateString() и toTimeString() – только дату и время соответственно.",
"Для получения текущей даты в миллисекундах лучше использовать Date.now(), чтобы не создавать лишний объект Date",
"Для бенчмаркинга лучше использовать performance.now() (кроме IE9-), он в 1000 раз точнее.",
"Глобальными называют переменные и функции, которые не находятся внутри какой-то функции. То есть, иными словами, если переменная или функция не находятся внутри конструкции function, то они – «глобальные».",
"В JavaScript все глобальные переменные и функции являются свойствами специального объекта, который называется «глобальный объект» (global object).",
"Присваивая или читая глобальную переменную, мы, фактически, работаем со свойствами window.",
"Во время инициализации скрипт сканируется на предмет объявления функций вида Function Declaration, а затем – на предмет объявления переменных var. Каждое такое объявление добавляется в window.",
"Функции, объявленные как Function Declaration, создаются сразу работающими, а переменные – равными undefined.",
"Все переменные внутри функции – это свойства специального внутреннего объекта LexicalEnvironment, который создаётся при её запуске.",
"Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем LexicalEnvironment, а затем, если её нет – ищет во внешнем объекте переменных. ",
"При создании функция получает скрытое свойство [[Scope]], которое ссылается на лексическое окружение, в котором она была создана.",
"Переменную во внешней области видимости можно не только читать, но и изменять.",
"Функция в JavaScript является объектом, поэтому можно присваивать свойства прямо к ней - f.test = 5; Свойства функции не стоит путать с переменными и параметрами. Они совершенно никак не связаны. Переменные доступны только внутри функции, они создаются в процессе её выполнения. Это – использование функции «как функции». А свойство у функции – доступно отовсюду и всегда. Это – использование функции «как объекта».",
"Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.",
"При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с места своего «рождения».",
"При создании функции с использованием new Function, её свойство [[Scope]] ссылается не на текущий LexicalEnvironment, а на window.",
"Есть одно упрощение для работы с памятью: «значение остаётся в памяти, пока на него есть хотя бы одна ссылка».",
"Свойства-функции называют «методами» объектов. Их можно добавлять и удалять в любой момент, в том числе и явным присваиванием",
"Если одну и ту же функцию запускать в контексте разных объектов, она будет получать разный this",
"Любой объект в логическом контексте – true, даже если это пустой массив [] или объект {}.",
"Если в объекте присутствует метод toString, который возвращает примитив, то он используется для преобразования.",
"Все объекты, включая встроенные, имеют свои реализации метода toString",
"У объектов Date есть и valueOf – возвращает количество миллисекунд, и toString – возвращает строку с датой.",
"При строковом преобразовании объекта используется его метод toString. Он должен возвращать примитивное значение, причём не обязательно именно строку.",
"Вызов return с объектом вернёт объект, а с чем угодно, кроме объекта – возвратит, как обычно, this.",
"Функции, которые предназначены для создания объектов, называются конструкторами. Их названия пишут с большой буквы, чтобы отличать от обычных.",
"Object.keys возвращает только enumerable-свойства.",
"Object.getOwnPropertyNames – возвращает все свойства.",
"\"Фабричный статический метод\" – удобная альтернатива такому конструктору. Так называется статический метод, который служит для создания новых объектов (поэтому и называется «фабричным»).",
"Вызов func.call(context, a, b...) – то же, что обычный вызов func(a, b...), но с явно указанным this(=context).",
"При помощи call можно легко взять метод одного объекта, в том числе встроенного, и вызвать в контексте другого. Это называется «одалживание метода» (на англ. method borrowing).",
"Вызов функции при помощи func.apply работает аналогично func.call, но принимает массив аргументов вместо списка.",
"Преимущество apply перед call отчётливо видно, когда мы формируем массив аргументов динамически.",
"Иными словами, в результате вызова bind(func, context) мы получаем «функцию-обёртку», которая прозрачно передаёт вызов в func, с теми же аргументами, но фиксированным контекстом context.",
"Методы bind и call/apply близки по синтаксису, но есть важнейшее отличие. Методы call/apply вызывают функцию с заданным контекстом и аргументами. А bind не вызывает функцию. Он только возвращает «обёртку», которую мы можем вызвать позже, и которая передаст вызов в исходную функцию, с привязанным контекстом.",
"Карринг (currying) или каррирование – термин функционального программирования, который означает создание новой функции путём фиксирования аргументов существующей.",
"Вызов bind часто используют для привязки функции к контексту, чтобы затем присвоить её в обычную переменную и вызывать уже без явного указания объекта.",
"Вызов bind также позволяет фиксировать первые аргументы функции («каррировать» её), и таким образом из общей функции получить её «частные» варианты – чтобы использовать их многократно без повтора одних и тех же аргументов каждый раз.",
"Декораторы способны упростить рутинные, повторяющиеся задачи, вынести их из кода функции.",
"Один раз пишем декоратор и дальше просто применяем этот функционал везде, где нужно.",
"Декоратор – это обёртка над функцией, которая модифицирует её поведение. При этом основную работу по-прежнему выполняет функция.",
"Декораторы можно не только повторно использовать, но и комбинировать!",
"Для получения [[Class]] нужна именно внутренняя реализация toString стандартного объекта Object, другая не подойдёт.",
"Для проверки типа на массив есть специальный метод: Array.isArray(arr). Он возвращает true только если arr – массив",
"Оператор instanceof позволяет проверить, создан ли объект данной функцией, причём работает для любых функций – как встроенных, так и наших.",
"Альтернативный подход к типу – «утиная типизация», которая основана на одной известной пословице: «If it looks like a duck, swims like a duck and quacks like a duck, then it probably is a duck (who cares what it really is)»",
"Для интеллектуального восстановления из строки у JSON.parse(str, reviver) есть второй параметр reviver, который является функцией function(key, value).",
"Метод JSON.stringify(value, replacer, space) преобразует («сериализует») значение в JSON-строку.",
"Во втором параметре JSON.stringify(value, replacer) можно указать массив свойств, которые подлежат сериализации.",
"Рекурсивный setTimeout – более гибкий метод тайминга, чем setInterval, так как время до следующего выполнения можно запланировать по-разному, в зависимости от результатов текущего.",
"Рекурсивный setTimeout гарантирует паузу между вызовами, setInterval – нет.",
"Если функция и выполняется дольше, чем пауза setInterval, то вызовы будут происходить вообще без перерыва.",
"При вызове eval имеет полный доступ к локальным переменным.",
"К счастью, существует отличная альтернатива eval, которая позволяет корректно взаимодействовать с внешним кодом: new Function.",
"При ошибке в try скрипт не «падает», и мы получаем возможность обработать ошибку внутри catch.",
"Ошибку, которая произойдёт в коде, запланированном «на будущее», например в setTimeout, try..catch не поймает",
"В случае, если данные некорректны, JSON.parse генерирует ошибку, то есть скрипт «упадёт».",
"В качестве конструктора ошибок можно использовать встроенный конструктор: new Error(message) или любой другой.",
"Ошибку, о которой catch не знает, он не должен обрабатывать.",
"Секцию finally используют, чтобы завершить начатые операции при любом варианте развития событий.",
"Локальные переменные, включая параметры конструктора, можно считать приватными свойствами.",
"К локальным переменным конструктора нельзя обратиться снаружи, но они доступны внутри самого конструктора. Свойства, записанные в this, можно считать публичными.",
"Подчёркивание в начале свойства – общепринятый знак, что свойство является внутренним, предназначенным лишь для доступа из самого объекта и его наследников. Такие свойства называют защищёнными.",
"Объект, на который указывает ссылка __proto__, называется «прототипом». В данном случае получилось, что animal является прототипом для rabbit.",
"Другими словами, прототип – это «резервное хранилище свойств и методов» объекта, автоматически используемое при поиске.",
"Чтобы новым объектам автоматически ставить прототип, конструктору ставится свойство prototype.",
"Значением Person.prototype по умолчанию является объект с единственным свойством constructor, содержащим ссылку на Person.",
"Все объекты наследуют от Object, а если более точно, то от Object.prototype.",
"Допустимо изменение прототипа встроенных объектов, которое добавляет поддержку метода из современных стандартов в те браузеры, где её пока нет.",
"Добавление методов в Object.prototype, если оно не сопровождается Object.defineProperty с установкой enumerable (IE9+), «сломает» циклы for..in, поэтому стараются в этот прототип методы не добавлять.",
"Для наследования нужно, чтобы «склад методов потомка» (Child.prototype) наследовал от «склада метода родителей» (Parent.prototype).",
"Для того, чтобы наследник создавался так же, как и родитель, он вызывает конструктор родителя в своём контексте, используя apply(this, arguments)",
"При переопределении метода родителя в потомке, к исходному методу можно обратиться, взяв его напрямую из прототипа",
"Оператор instanceof позволяет проверить, какому классу принадлежит объект, с учетом прототипного наследования.",
"Можно получить всех потомков, передав звездочку '*' вместо тега: document.getElementsByTagName('*');",
"Метод elem.closest(css) ищет ближайший элемент выше по иерархии DOM, подходящий под CSS-селектор css. Сам элемент тоже включается в поиск.",
"Язык запросов XPath поддерживается большинством браузеров, кроме IE, даже 9-й версии, но querySelector удобнее. Поэтому XPath используется редко.",
"Чтобы производительность getElementsBy* была достаточно хорошей, активно используется кеширование результатов поиска.",
"Существует целых два свойства: nodeName и tagName, которые содержат название(тег) элемента узла. Название HTML-тега всегда находится в верхнем регистре.",
"Содержимое других узлов, например, текстовых или комментариев, доступно на чтение и запись через свойство data.",
"elem.textContent возвращает конкатенацию всех текстовых узлов внутри elem.",
"Узел DOM – это объект, поэтому, как и любой объект в JavaScript, он может содержать пользовательские свойства и методы.",
"Свойство classList – это объект для работы с классами.",
"Свойство style.cssText позволяет поставить стиль целиком в виде строки.",
"При установке style.cssText все предыдущие свойства style удаляются.",
"Для того, чтобы получить текущее используемое значение свойства, используется метод window.getComputedStyle",
"Метод scrollTo(pageX,pageY) прокручивает страницу к указанным координатам относительно документа.",
"Чтобы запретить прокрутку страницы, достаточно поставить document.body.style.overflow = \"hidden\".",
"Для получения размеров видимой части окна: document.documentElement.clientWidth/Height",
"Прокрутку окна можно получить как window.pageYOffset (для горизонтальной – window.pageXOffset) везде, кроме IE8-.",
"window.scrollTo(pageX,pageY) – абсолютные координаты",
"window.scrollBy(x,y) – прокрутить относительно текущего места.",
"elem.scrollIntoView(top) – прокрутить, чтобы элемент elem стал виден.",
"Координаты относительно окна не учитывают прокрутку, они высчитываются от границ текущей видимой области.",
"Когда происходит событие, оно попадает в очередь. Иногда события добавляются в очередь сразу пачкой.",
"При наступлении события обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе, затем выше и так далее, вверх по цепочке вложенности.",
"Самый глубокий элемент, который вызывает событие, называется «целевым» или «исходным» элементом и доступен как event.target.",
"Для отмены действия браузера существует стандартный метод event.preventDefault().",
"Браузер имеет встроенные действия при ряде событий – переход по ссылке, отправка формы и т.п. Как правило, их можно отменить.",
"сть два способа отменить действие по умолчанию: первый – использовать event.preventDefault() (IE8-: event.returnValue=false), второй – return false из обработчика. Второй способ работает только если обработчик назначен через onсобытие.",
"Для поддержки Ctrl+click не забываем проверить if (e.metaKey || e.ctrlKey), чтобы пользователи Mac тоже были довольны.",
"При переходе на потомка срабатывает mouseout на родителе.",
"Согласно браузерной логике, указатель мыши может быть только над одним элементом – самым глубоким в DOM (и верхним по z-index).",
"onscroll происходит после прокрутки, а onwheel – до прокрутки, поэтому в нём можно отменить саму прокрутку (действие браузера).",
];

// Генерация случаюного числа от одного до максимального числа массива
function getRandomInRange() {
	var min = 1;
	var max = arr.length - 1;

 	return Math.floor(Math.random() * (max - min + 1)) + min;
}

// Получение случайной строки
function GetString() {
	var num = getRandomInRange(),
		content = arr[num];

		return content;
} 

function WriteText() {
	var text = document.querySelector("#text");
	text.textContent = GetString();

	text.style.textAlign = 'left';
	text.style.fontSize = '1em';

	if (text.textContent.length < 90) {
		text.style.textAlign = 'center';
		text.style.fontSize = '1.2em';
	}

}

// function slideIt(time) {
// 	setInterval(WriteText, time);
// }
//
// slideIt(3000);

var text = document.querySelector('#text');
text.onclick = function () {
    WriteText();
}
